// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.5;

/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {

    /**
     * @dev Indicates that the contract has been initialized.
   */
    bool private initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
   */
    bool private initializing;

    /**
     * @dev Modifier to use in the initializer function of a contract.
   */
    modifier initializer() {
        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

        bool isTopLevelCall = !initializing;
        if (isTopLevelCall) {
            initializing = true;
            initialized = true;
        }

        _;

        if (isTopLevelCall) {
            initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly { cs := extcodesize(self) }
        return cs == 0;
    }
}

interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library LowGasSafeMath {
    /// @notice Returns x + y, reverts if sum overflows uint256
    /// @param x The augend
    /// @param y The addend
    /// @return z The sum of x and y
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x);
    }

    /// @notice Returns x - y, reverts if underflows
    /// @param x The minuend
    /// @param y The subtrahend
    /// @return z The difference of x and y
    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x);
    }

    /// @notice Returns x * y, reverts if overflows
    /// @param x The multiplicand
    /// @param y The multiplier
    /// @return z The product of x and y
    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(x == 0 || (z = x * y) / x == y);
    }

    /// @notice Returns x + y, reverts if overflows or underflows
    /// @param x The augend
    /// @param y The addend
    /// @return z The sum of x and y
    function add(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x + y) >= x == (y >= 0));
    }

    /// @notice Returns x - y, reverts if overflows or underflows
    /// @param x The minuend
    /// @param y The subtrahend
    /// @return z The difference of x and y
    function sub(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x - y) <= x == (y >= 0));
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }
}

abstract contract ERC20 is IERC20, Initializable {

    using LowGasSafeMath for uint256;

    // Present in ERC777
    mapping (address => uint256) internal _balances;

    // Present in ERC777
    mapping (address => mapping (address => uint256)) internal _allowances;

    // Present in ERC777
    uint256 internal _totalSupply;

    // Present in ERC777
    string internal _name;

    // Present in ERC777
    string internal _symbol;

    // Present in ERC777
    uint8 internal _decimals;

    function __ERC20_init_unchained(string memory name_, string memory symbol_, uint8 decimals_) internal initializer {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender]
            .sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]
            .sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }


    function _sub_balances(address account_, uint256 amount_) internal  {
        require(account_ != address(0), "ERC20: mint to the zero address");
        _balances[account_] = _balances[account_].sub(amount_);
    }
    function _add_balances(address account_, uint256 amount_) internal  {
        require(account_ != address(0), "ERC20: mint to the zero address");
        _balances[account_] = _balances[account_].add(amount_);
    }

    function _mint(address account_, uint256 amount_) internal virtual {
        require(account_ != address(0), "ERC20: mint to the zero address");
        _beforeTokenTransfer(address( this ), account_, amount_);
        _totalSupply = _totalSupply.add(amount_);
        _balances[account_] = _balances[account_].add(amount_);
        emit Transfer(address(0), account_, amount_);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount);
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }
}

library Counters {
    using LowGasSafeMath for uint256;

    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}

interface IERC2612Permit {

    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function nonces(address owner) external view returns (uint256);
}

abstract contract ERC20Permit is ERC20, IERC2612Permit {
    using Counters for Counters.Counter;

    mapping(address => Counters.Counter) private _nonces;

    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    bytes32 public DOMAIN_SEPARATOR;

    constructor() {
        uint256 chainID;
        assembly {
            chainID := chainid()
        }

        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(name())),
                keccak256(bytes("1")), // Version
                chainID,
                address(this)
            )
        );
    }

    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "Permit: expired deadline");

        bytes32 hashStruct =
        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));

        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));

        address signer = ecrecover(_hash, v, r, s);
        require(signer != address(0) && signer == owner, "ERC20Permit: Invalid signature");

        _nonces[owner].increment();
        _approve(owner, spender, amount);
    }

    function nonces(address owner) public view override returns (uint256) {
        return _nonces[owner].current();
    }
}

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

interface IOwnable {
    function owner() external view returns (address);

    function renounceOwnership() external;

    function transferOwnership( address newOwner_ ) external;
}

contract Ownable is IOwnable, Initializable {

    address internal _owner;
    address internal _pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferring(address indexed owner, address indexed pendingOwner);

    function __Ownable_init_unchain() internal initializer {
        require(_owner == address(0));
        _owner = msg.sender;
        emit OwnershipTransferred( address(0), _owner );
    }

    function owner() public view override returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require( _owner == msg.sender, "Ownable: caller is not the owner" );
        _;
    }

    function renounceOwnership() public virtual override onlyOwner() {
        emit OwnershipTransferred( _owner, address(0) );
        _owner = address(0);
    }

    function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {
        require( newOwner_ != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferring( _owner, newOwner_ );
        _pendingOwner = newOwner_;
    }

    function acceptOwnership() external {
        require(_pendingOwner == msg.sender, "Permission denied");
        emit OwnershipTransferred( _owner, msg.sender );
        _owner = msg.sender;
    }
}

contract VaultOwned is Ownable {

    function __VaultOwned_init_unchain() internal initializer {
        __Ownable_init_unchain();
    }

    address internal _vault;

    event VaultTransferred(address indexed newVault);

    function setVault( address vault_ ) external onlyOwner() {
        require(vault_ != address(0), "IA0");
        _vault = vault_;
        emit VaultTransferred( _vault );
    }

    function vault() public view returns (address) {
        return _vault;
    }

    modifier onlyVault() {
        require( _vault == msg.sender, "VaultOwned: caller is not the Vault" );
        _;
    }

}

interface ISATTimelock {
    function increaseReward() external;
}
struct LOCK_OBJ {
    uint release_time;
    uint256 balance;
}
struct LOCK_INFO {
    LOCK_OBJ[] lock_array;
}

contract SATERC20Token is ERC20Permit, VaultOwned, Pausable {
    using LowGasSafeMath for uint256;
    uint256 public constant CAP = 10**8 * 1 ether;
    uint256 public constant RATIO_FEE = 0.1 ether;

    address public feeAddress;
    mapping(address => bool) public isTransferWhitelist;
    mapping(address => LOCK_INFO) internal lock;

    function __SATERC20Token_initialize() external initializer {
        __ERC20_init_unchained("Synassets Token", "SAT", 18);
        __VaultOwned_init_unchain();
    }

    function internal_mint(address account_, uint256 amount_) internal{
        require(totalSupply().add(amount_) <= CAP, 'CE');
        _mint(account_, amount_);
        if (feeAddress != address(0)) {
            uint256 fee_ = amount_.mul(RATIO_FEE).div(1 ether);
            require(totalSupply().add(fee_) <= CAP, 'CE');

            _mint(feeAddress, fee_);
            ISATTimelock(feeAddress).increaseReward();
        }
    }

    function mint(address account_, uint256 amount_) external onlyVault() {
          internal_mint(account_,  amount_);
    }


    function _freeze(address account_,uint256 amount_,uint256 release_time)internal {
//        require(release_time < block.timestamp +365*24*3600, 'release time is too long');
//        require(release_time > block.timestamp , 'release time is before now');
        _sub_balances(account_,amount_);
        lock[account_].lock_array.push(LOCK_OBJ(release_time,amount_));
    }

    function lock_mint(address account_, uint256 amount_,uint256 release_time) external onlyOwner() {
        internal_mint(account_, amount_);
        _freeze(account_,amount_,release_time);
    }
    function lock_mint_batch(address[] calldata account_, uint256 amount_,uint256 release_time) external onlyOwner() {
       for (uint256 index = 0; index < account_.length; index ++) {
            internal_mint(account_[index], amount_);
            _freeze(account_[index],amount_,release_time);
        }

    }

    function get_LOCK_INFO(address account_) public view returns (uint256,uint256,uint256,uint256) {
        LOCK_INFO memory  info =  lock[account_];
        return (info.lock_array.length, info.lock_array[0].release_time,info.lock_array[0].balance,block.timestamp);
    }

    function freezedBalanceOf(address account_) public view returns (uint256) {
        uint256 ret = 0 ;
        LOCK_INFO memory  info =  lock[account_];
        LOCK_OBJ memory obj ;
        for(uint256 i = 0 ; i <info.lock_array.length ;i++){
            obj = info.lock_array[i];
            if(obj.release_time > block.timestamp){
                ret =  ret.add(obj.balance);
            }
        }
        return ret;
    }
    function LockedInfoBalanceOf(address account_) internal view returns (uint256) {
        uint256 ret = 0 ;
        LOCK_INFO memory  info =  lock[account_];
        LOCK_OBJ memory obj ;
        for(uint256 i = 0 ; i <info.lock_array.length ;i++){
            obj = info.lock_array[i];
            if(obj.release_time > 0){
                ret =  ret.add(obj.balance);
            }
        }
        return ret;
    }

    function update_freezed_balances(address account_) internal  {
        uint256 time = 0 ;
        LOCK_INFO memory  info =  lock[account_];
        if(info.lock_array.length == 0){
            return ;
        }
        uint256 ret = 0 ;
        LOCK_INFO storage sInfo =  lock[account_];
        for(uint256 i = 0 ; i <info.lock_array.length ;i++){
            time = info.lock_array[i].release_time;
            if(time > 0 && time < block.timestamp){
                sInfo.lock_array[i].release_time = 0;
                sInfo.lock_array[i].balance = 0;
                ret =  ret.add(info.lock_array[i].balance);
            }
        }
        _add_balances(account_,ret);
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return super.balanceOf(account).add(LockedInfoBalanceOf(account));
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        update_freezed_balances(msg.sender);
        super.transfer( recipient, amount);
        return true;
    }
    function burn(uint256 amount_) external virtual {
        _burn(msg.sender, amount_);
    }

    function burnFrom(address account_, uint256 amount_) external virtual {
        _burnFrom(account_, amount_);
    }

    function _burnFrom(address account_, uint256 amount_) internal virtual {
        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(amount_);

        _approve(account_, msg.sender, decreasedAllowance_);
        _burn(account_, amount_);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        require(!paused() || isTransferWhitelist[from], "ERC20Pausable: token transfer while paused");
    }

    function addWhitelist(address account_) external onlyOwner {
        isTransferWhitelist[account_] = true;
    }

    function removeWhitelist(address account_) external onlyOwner {
        delete isTransferWhitelist[account_];
    }

    function unpauseTransfer() external onlyOwner {
        _unpause();
    }

    function pauseTransfer() external onlyOwner {
        _pause();
    }

    function setFeeAddress(address feeAddress_) external onlyOwner {
        feeAddress = feeAddress_;
    }

    function maxSupply() public pure returns (uint256) {
        return CAP;
    }
}
